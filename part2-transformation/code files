-------------------------------------------------------------------------------
-- 1. STAGING: stg_events
-- Canonical event table: cleaned IDs, timestamps, JSON fields, channels, device
-------------------------------------------------------------------------------

create or replace view stg_events as
with base as (
    select
        -- Normalize user identifier (handles client_id vs clientId)
        coalesce(client_id, "clientId")                 as user_id,
        client_id,
        "clientId"                                      as clientId,

        page_url,
        referrer,
        event_name,
        event_data,         -- assumed JSONB; cast if needed
        user_agent,

        -- Parse timestamp (column name is "timestamp" in the raw data)
        ("timestamp")::timestamptz                      as event_ts
    from raw_events_validated
),

parsed as (
    select
        *,
        event_ts::date                                   as event_date,

        -- Parse purchase fields from JSON
        (event_data::jsonb ->> 'transaction_id')         as transaction_id,
        (event_data::jsonb ->> 'revenue')::numeric       as revenue,

        -- UTM fields (if present in JSON)
        event_data::jsonb ->> 'utm_source'               as utm_source,
        event_data::jsonb ->> 'utm_medium'               as utm_medium,
        event_data::jsonb ->> 'utm_campaign'             as utm_campaign
    from base
),

with_channel as (
    select
        *,
        case
            when utm_medium in ('cpc', 'paid_search') then 'Paid Search'
            when utm_medium in ('paid_social', 'social') then 'Paid Social'
            when utm_medium = 'email' then 'Email'
            when utm_medium is not null then 'Other Paid'
            when referrer is null then 'Direct'
            when referrer ilike '%google.%' then 'Organic Search'
            when referrer ilike '%facebook.%'
              or referrer ilike '%instagram.%' then 'Social'
            else 'Referral'
        end as channel,

        case
            when user_agent ilike '%mobile%'
              or user_agent ilike '%iphone%'
              or user_agent ilike '%android%' then 'Mobile'
            when user_agent is null then 'Unknown'
            else 'Desktop'
        end as device_type
    from parsed
)

select * from with_channel;



-------------------------------------------------------------------------------
-- 2. SESSION EVENTS: fct_session_events
-- Adds session_id to every event using 30-min inactivity rule
-------------------------------------------------------------------------------

create or replace view fct_session_events as
with ordered as (
    select
        *,
        lag(event_ts) over (
            partition by user_id
            order by event_ts
        ) as prev_event_ts
    from stg_events
),

flagged as (
    select
        *,
        case
            when prev_event_ts is null then 1
            when event_ts - prev_event_ts > interval '30 minutes' then 1
            else 0
        end as is_new_session
    from ordered
),

sessioned as (
    select
        *,
        sum(is_new_session) over (
            partition by user_id
            order by event_ts
            rows between unbounded preceding and current row
        ) as session_seq
    from flagged
)

select
    user_id,
    client_id,
    clientId,
    page_url,
    referrer,
    event_name,
    event_data,
    user_agent,
    event_ts,
    event_date,
    transaction_id,
    revenue,
    utm_source,
    utm_medium,
    utm_campaign,
    channel,
    device_type,
    session_seq,
    (user_id || '-' || session_seq)::varchar as session_id
from sessioned;



-------------------------------------------------------------------------------
-- 3. SESSIONS: fct_sessions
-- One row per session: start/end, entry info, device, counts
-------------------------------------------------------------------------------

create or replace view fct_sessions as
with base as (
    select
        session_id,
        user_id,
        min(event_ts)            as session_start_ts,
        max(event_ts)            as session_end_ts,
        min(event_ts)::date      as session_date,
        count(*)                 as event_count
    from fct_session_events
    group by session_id, user_id
),

entry as (
    select
        session_id,
        -- First event in session for entry attributes
        first_value(event_name)      over w as entry_event_name,
        first_value(page_url)        over w as entry_page_url,
        first_value(channel)         over w as entry_channel,
        first_value(utm_source)      over w as entry_utm_source,
        first_value(utm_medium)      over w as entry_utm_medium,
        first_value(utm_campaign)    over w as entry_utm_campaign,
        first_value(device_type)     over w as device_type
    from fct_session_events
    window w as (
        partition by session_id
        order by event_ts
        rows between unbounded preceding and unbounded following
    )
),

entry_dedup as (
    select distinct
        session_id,
        entry_event_name,
        entry_page_url,
        entry_channel,
        entry_utm_source,
        entry_utm_medium,
        entry_utm_campaign,
        device_type
    from entry
)

select
    b.session_id,
    b.user_id,
    b.session_start_ts,
    b.session_end_ts,
    b.session_date,
    b.event_count,
    e.entry_event_name,
    e.entry_page_url,
    e.entry_channel,
    e.entry_utm_source,
    e.entry_utm_medium,
    e.entry_utm_campaign,
    e.device_type
from base b
join entry_dedup e using (session_id);



-------------------------------------------------------------------------------
-- 4. USERS: dim_users
-- Aggregated user behavior & revenue
-------------------------------------------------------------------------------

create or replace view dim_users as
with user_activity as (
    select
        user_id,
        min(event_ts)              as first_seen_ts,
        max(event_ts)              as last_seen_ts,
        count(*)                   as total_events,
        count(distinct session_id) as session_count,
        count(*) filter (where event_name = 'page_viewed')              as pageviews,
        count(*) filter (where event_name = 'product_added_to_cart')    as adds_to_cart,
        count(*) filter (where event_name = 'checkout_started')         as checkouts_started,
        count(*) filter (where event_name in ('purchase','checkout_completed')) as purchases,
        coalesce(sum(revenue) filter (where event_name in ('purchase','checkout_completed')), 0)
                                   as total_revenue
    from fct_session_events
    group by user_id
)

select * from user_activity;



-------------------------------------------------------------------------------
-- 5. ORDERS: fct_orders
-- One row per transaction_id (deduped), with chosen revenue & order_ts
-------------------------------------------------------------------------------

create or replace view fct_orders as
with purchases as (
    select
        user_id,
        event_ts,
        event_date,
        transaction_id,
        revenue,
        channel,
        utm_source,
        utm_medium,
        utm_campaign
    from stg_events
    where event_name in ('purchase','checkout_completed')
      and transaction_id is not null
),

agg as (
    select
        transaction_id            as order_id,
        max(user_id)              as user_id,          -- should be unique
        max(event_ts)             as order_ts,         -- latest wins
        max(event_date)           as order_date,
        max(revenue)              as revenue,          -- conservative choice
        max(channel)              as order_channel,
        max(utm_source)           as order_utm_source,
        max(utm_medium)           as order_utm_medium,
        max(utm_campaign)         as order_utm_campaign
    from purchases
    group by transaction_id
)

select * from agg;



-------------------------------------------------------------------------------
-- 6. MARKETING TOUCHES: fct_marketing_touches
-- Session-entry non-Direct touches eligible for attribution
-------------------------------------------------------------------------------

create or replace view fct_marketing_touches as
select
    -- touch_id can be a surrogate key; here we just reuse session_id
    session_id                 as touch_id,
    session_id,
    user_id,
    session_start_ts           as touch_ts,
    session_date               as touch_date,
    entry_channel              as channel,
    entry_utm_source           as utm_source,
    entry_utm_medium           as utm_medium,
    entry_utm_campaign         as utm_campaign
from fct_sessions
where entry_channel is not null
  and entry_channel <> 'Direct';



-------------------------------------------------------------------------------
-- 7. ORDER ATTRIBUTION: fct_order_attribution
-- First-click and last-click models with 7-day lookback
-------------------------------------------------------------------------------

create or replace view fct_order_attribution as
with eligible_touches as (
    select
        o.order_id,
        o.user_id,
        o.order_ts,
        o.order_date,
        o.revenue,
        t.touch_id,
        t.session_id,
        t.touch_ts,
        t.channel,
        t.utm_source,
        t.utm_medium,
        t.utm_campaign,
        row_number() over (
            partition by o.order_id
            order by t.touch_ts asc
        ) as rn_first,
        row_number() over (
            partition by o.order_id
            order by t.touch_ts desc
        ) as rn_last
    from fct_orders o
    join fct_marketing_touches t
      on t.user_id = o.user_id
     and t.touch_ts between (o.order_ts - interval '7 days') and o.order_ts
),

first_click as (
    select
        'first_click'                   as model,
        order_id,
        user_id,
        order_ts,
        order_date,
        revenue,
        touch_id,
        session_id,
        touch_ts,
        channel,
        utm_source,
        utm_medium,
        utm_campaign
    from eligible_touches
    where rn_first = 1
),

last_click as (
    select
        'last_click'                    as model,
        order_id,
        user_id,
        order_ts,
        order_date,
        revenue,
        touch_id,
        session_id,
        touch_ts,
        channel,
        utm_source,
        utm_medium,
        utm_campaign
    from eligible_touches
    where rn_last = 1
)

select * from first_click
union all
select * from last_click;



