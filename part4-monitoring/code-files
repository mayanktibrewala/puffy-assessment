Below is a concise Python script that assumes a daily_metrics table like:
event_date, events, users, pageviews,
add_to_cart, checkout_started,
orders, revenue,
pct_missing_user_id,
duplicate_orders,
attributed_orders, attributed_revenue
You’d run this in Airflow/dbt Cloud after your models finish.
import sys
import statistics
import pandas as pd
from sqlalchemy import create_engine, text  # adapt to your warehouse

# --- Config ---
DAYS_HISTORY = 8       # 7-day baseline + today
CRIT_DROP_FRACTION = 0.2
WARN_DROP_FRACTION = 0.5
CRIT_Z = 6.0
WARN_Z = 4.0

ENGINE = create_engine("postgresql://user:pass@host:5432/db")  # example


def mad(values):
    """Median Absolute Deviation."""
    med = statistics.median(values)
    devs = [abs(v - med) for v in values]
    m = statistics.median(devs)
    return m if m != 0 else 1.0


def z_score(today, history):
    if len(history) < 3:
        return 0.0
    return (today - statistics.median(history)) / mad(history)


def fetch_daily_metrics():
    q = text("""
        select *
        from daily_metrics
        order by event_date desc
        limit :limit
    """)
    with ENGINE.connect() as conn:
        df = pd.read_sql(q, conn, params={"limit": DAYS_HISTORY})
    return df.sort_values("event_date").reset_index(drop=True)


def main():
    df = fetch_daily_metrics()
    if df.empty:
        print("[CRITICAL] daily_metrics is empty.")
        sys.exit(1)

    history = df.iloc[:-1].copy()
    today = df.iloc[-1].copy()
    date_today = today["event_date"]

    alerts = []
    critical = False

    def check_volume(metric):
        nonlocal critical
        if metric not in df.columns:
            return
        hist_vals = history[metric].astype(float).tolist()
        today_val = float(today[metric])
        if not hist_vals:
            return
        base_med = statistics.median(hist_vals)
        if base_med <= 0:
            return

        frac = today_val / base_med
        z = z_score(today_val, hist_vals)

        if today_val == 0:
            alerts.append(f"[CRITICAL] {metric} is zero on {date_today}.")
            critical = True
        elif frac < CRIT_DROP_FRACTION or abs(z) >= CRIT_Z:
            alerts.append(
                f"[CRITICAL] {metric}={today_val:.1f} vs median {base_med:.1f} "
                f"(z≈{z:.1f}, frac={frac:.2f})."
            )
            critical = True
        elif frac < WARN_DROP_FRACTION or abs(z) >= WARN_Z:
            alerts.append(
                f"[WARN] {metric}={today_val:.1f} vs median {base_med:.1f} "
                f"(z≈{z:.1f}, frac={frac:.2f})."
            )

    # 1) Volume / ingestion
    for metric in ["events", "users", "orders", "revenue"]:
        check_volume(metric)

    # 2) Data quality
    pct_missing = float(today.get("pct_missing_user_id", 0) or 0)
    if pct_missing > 0.10:
        alerts.append(f"[CRITICAL] pct_missing_user_id={pct_missing:.2%} (>10%).")
        critical = True
    elif pct_missing > 0.05:
        alerts.append(f"[WARN] pct_missing_user_id={pct_missing:.2%} (>5%).")

    dup_orders = int(today.get("duplicate_orders", 0) or 0)
    if dup_orders > 0:
        alerts.append(f"[CRITICAL] duplicate_orders={dup_orders} on {date_today}.")
        critical = True

    orders = float(today.get("orders", 0) or 0)
    revenue = float(today.get("revenue", 0) or 0)
    attributed_orders = float(today.get("attributed_orders", 0) or 0)
    attributed_revenue = float(today.get("attributed_revenue", 0) or 0)

    if orders > 0:
        cov_o = attributed_orders / orders
        if cov_o < 0.3:
            alerts.append(
                f"[WARN] Only {cov_o:.1%} of orders attributed "
                f"({attributed_orders}/{orders}) on {date_today}."
            )
    if revenue > 0:
        cov_r = attributed_revenue / revenue
        if cov_r < 0.3:
            alerts.append(
                f"[WARN] Only {cov_r:.1%} of revenue attributed "
                f"({attributed_revenue:.1f}/{revenue:.1f}) on {date_today}."
            )

    # 3) Funnel sanity (simple thresholds)
    if all(col in today for col in ["pageviews", "add_to_cart", "checkout_started"]):
        pv = float(today["pageviews"])
        ac = float(today["add_to_cart"])
        cs = float(today["checkout_started"])

        conv = orders / pv if pv > 0 else 0
        ac_rate = ac / pv if pv > 0 else 0
        cs_rate = cs / ac if ac > 0 else 0
        pur_rate = orders / cs if cs > 0 else 0

        if conv < 0.001:  # <0.1%
            alerts.append(f"[CRITICAL] Conversion extremely low: {conv:.2%}.")
            critical = True
        if ac_rate < 0.01:
            alerts.append(f"[WARN] Add-to-cart rate low: {ac_rate:.2%}.")
        if cs_rate < 0.2 and ac > 20:
            alerts.append(f"[WARN] Checkout-start rate low: {cs_rate:.2%}.")
        if pur_rate < 0.2 and cs > 20:
            alerts.append(f"[WARN] Checkout→purchase rate low: {pur_rate:.2%}.")

    # --- Output ---
    if not alerts:
        print(f"[OK] No issues detected for {date_today}.")
        sys.exit(0)

    print(f"Monitoring report for {date_today}:")
    for msg in alerts:
        print("  " + msg)

    sys.exit(1 if critical else 0)


if __name__ == "__main__":
    main()
